// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [pgvector(map: "vector")]
}

// ============================================================================
// USER & AUTHENTICATION
// ============================================================================

model User {
  id              String    @id @db.Uuid
  email           String    @unique
  fullName        String?   @map("full_name")
  avatarUrl       String?   @map("avatar_url")
  provider        String?   // 'google' or 'microsoft'
  providerId      String?   @map("provider_id")
  firmId          String?   @map("firm_id") @db.Uuid
  roles           String[]  @default(["user"])

  // Subscription
  subscriptionTier    String   @default("free") @map("subscription_tier") // free, starter, professional, enterprise
  subscriptionStatus  String   @default("active") @map("subscription_status") // active, trialing, past_due, canceled
  stripeCustomerId    String?  @unique @map("stripe_customer_id")
  stripeSubscriptionId String? @unique @map("stripe_subscription_id")
  subscriptionEndsAt  DateTime? @map("subscription_ends_at")
  trialEndsAt         DateTime? @map("trial_ends_at")

  // User Settings (includes feature toggles)
  settings        Json      @default("{}")

  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  lastLoginAt     DateTime? @map("last_login_at")

  // Relations
  matters         Matter[]
  sessions        Session[]
  apiKeys         EncryptedApiKey[]
  auditLogs       AuditLog[]
  exportJobs      ExportJob[]
  conflictChecks  ConflictCheck[]
  billableTime    BillableTime[]
  templates       DocumentTemplate[]
  generatedDocs   GeneratedDocument[]
  aiUsage         ai_usage[]

  @@index([email])
  @@index([firmId])
  @@index([subscriptionTier, subscriptionStatus])
  @@map("profiles")
}

model EncryptedApiKey {
  id              String   @id @default(cuid())
  userId          String   @map("user_id") @db.Uuid
  provider        String   // 'deepgram', 'assemblyai', 'anthropic', 'openai', 'google', 'openrouter'
  encryptedKey    String   @map("encrypted_key") @db.Text // Format: version:nonce:ciphertext
  maskedKey       String?  @map("masked_key") // For display: "sk-12••••••3456"
  isActive        Boolean  @default(true) @map("is_active")
  lastTestedAt    DateTime? @map("last_tested_at")
  testStatus      String?  @map("test_status") // 'success', 'failed', 'pending'
  testError       String?  @map("test_error") @db.Text
  createdAt       DateTime @default(now()) @map("created_at")
  lastUsedAt      DateTime? @map("last_used_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@index([userId, isActive])
  @@map("encrypted_api_keys")
}

// ============================================================================
// SUBSCRIPTION & BILLING
// ============================================================================

model SubscriptionPlan {
  id              String   @id @default(cuid())
  name            String   @unique // "Free", "Starter", "Professional", "Enterprise"
  slug            String   @unique // "free", "starter", "professional", "enterprise"
  description     String?  @db.Text

  // Pricing
  priceMonthly    Int      // Cents (e.g., 2900 = $29.00)
  priceYearly     Int      // Cents with discount
  stripePriceIdMonthly  String?
  stripePriceIdYearly   String?

  // Limits
  maxSessions     Int      @default(-1) // -1 = unlimited
  maxStorageGB    Int      @default(-1) // -1 = unlimited
  maxAIRequests   Int      @default(-1) // Per month, -1 = unlimited
  maxMatters      Int      @default(-1)
  maxUsers        Int      @default(1)  // For firm accounts

  // Features (JSON for flexibility)
  features        Json     @default("{}")

  isActive        Boolean  @default(true)
  sortOrder       Int      @default(0)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([isActive, sortOrder])
  @@map("subscription_plans")
}

model Invoice {
  id              String   @id @default(cuid())
  userId          String   @db.Uuid
  stripeInvoiceId String   @unique

  // Invoice details
  amountDue       Int      // Cents
  amountPaid      Int      // Cents
  currency        String   @default("usd")
  status          String   // draft, open, paid, void, uncollectible

  // Dates
  periodStart     DateTime
  periodEnd       DateTime
  dueDate         DateTime?
  paidAt          DateTime?

  // Files
  invoicePdf      String?
  hostedUrl       String?

  createdAt       DateTime @default(now())

  @@index([userId, createdAt])
  @@index([status])
  @@map("invoices")
}

model UsageMetrics {
  id              String   @id @default(cuid())
  userId          String   @db.Uuid

  // Period
  periodStart     DateTime
  periodEnd       DateTime

  // Metrics
  sessionsCount   Int      @default(0)
  transcriptionMinutes Float @default(0)
  aiRequestsCount Int      @default(0)
  storageUsedGB   Float    @default(0)

  // Costs
  transcriptionCost Float  @default(0)
  aiCost          Float    @default(0)
  storageCost     Float    @default(0)
  totalCost       Float    @default(0)

  createdAt       DateTime @default(now())

  @@unique([userId, periodStart])
  @@index([userId, periodEnd])
  @@map("usage_metrics")
}

// ============================================================================
// MATTERS & SESSIONS
// ============================================================================

model Matter {
  id              String   @id @default(cuid())
  name            String
  clientName      String
  adverseParty    String?
  jurisdiction    String?
  courtType       String?
  caseNumber      String?
  status          String   @default("active")
  userId          String   @db.Uuid
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  sessions        Session[]
  documents       GeneratedDocument[]
  billableTime    BillableTime[]

  @@index([userId, status])
  @@index([clientName])
  @@map("matters")
}

model Session {
  id                    String    @id @default(cuid())
  matterId              String
  userId                String    @db.Uuid

  status                String    @default("active")
  title                 String?
  description           String?   @db.Text

  startedAt             DateTime  @default(now())
  endedAt               DateTime?
  durationMs            Int?

  audioStoragePath      String?
  transcriptData        Json?

  shareToken            String?   @unique
  shareExpiresAt        DateTime?
  shareScope            String?

  totalCost             Float     @default(0)
  asrProvider           String?
  asrCost               Float     @default(0)
  aiProvider            String?
  aiCost                Float     @default(0)

  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  matter                Matter    @relation(fields: [matterId], references: [id], onDelete: Cascade)
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  segments              TranscriptSegment[]
  chatMessages          ChatMessage[]
  versions              TranscriptVersion[]
  accessLogs            TranscriptAccessLog[]
  redactions            Redaction[]
  speakers              Speaker[]
  timestampProofs       TimestampProof[]
  exportJobs            ExportJob[]
  billableTime          BillableTime[]
  generatedDocs         GeneratedDocument[]

  @@index([userId, status, startedAt])
  @@index([matterId, startedAt])
  @@index([shareToken])
  @@map("sessions")
}

// ============================================================================
// FEATURE 1: AUDIT LOGGING
// ============================================================================

model AuditLog {
  id              String    @id @default(cuid())
  userId          String?   @map("user_id") @db.Uuid
  sessionId       String?   @map("session_id")
  matterId        String?   @map("matter_id")

  action          String
  resource        String
  resourceId      String?   @map("resource_id")

  clientName      String?   @map("client_name")

  oldValue        Json?     @map("old_value")
  newValue        Json?     @map("new_value")
  changeReason    String?   @map("change_reason")

  ipAddress       String?   @map("ip_address")
  userAgent       String?   @map("user_agent")
  location        String?

  retentionUntil  DateTime? @map("retention_until")
  isPrivileged    Boolean   @default(true) @map("is_privileged")

  metadata        Json      @default("{}")
  createdAt       DateTime  @default(now()) @map("created_at")

  user            User?     @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([sessionId, createdAt])
  @@index([matterId, createdAt])
  @@index([action, resource])
  @@index([clientName, createdAt])
  @@map("audit_logs")
}

// ============================================================================
// FEATURE 2: VERSION CONTROL
// ============================================================================

model TranscriptVersion {
  id              String   @id @default(cuid())
  sessionId       String
  version         Int

  segments        Json

  changeType      String
  changedBy       String
  changeReason    String?

  diffSummary     Json?

  createdAt       DateTime @default(now())

  session         Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, version])
  @@index([sessionId, createdAt])
  @@index([changedBy, createdAt])
  @@map("transcript_versions")
}

// ============================================================================
// FEATURE 3: TIMESTAMP VERIFICATION
// ============================================================================

model TimestampProof {
  id              String   @id @default(cuid())
  sessionId       String
  segmentId       String

  contentHash     String
  timestamp       DateTime
  timestampSource String

  rfc3161Token    String?  @db.Text

  isVerified      Boolean  @default(false)
  verifiedAt      DateTime?
  verifiedBy      String?
  verificationMethod String?

  createdAt       DateTime @default(now())

  session         Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  segment         TranscriptSegment @relation(fields: [segmentId], references: [id], onDelete: Cascade)

  @@unique([segmentId])
  @@index([sessionId, timestamp])
  @@index([isVerified, timestamp])
  @@map("timestamp_proofs")
}

// ============================================================================
// FEATURE 5: SPEAKER IDENTIFICATION
// ============================================================================

model Speaker {
  id              String   @id @default(cuid())
  sessionId       String

  name            String
  role            String?
  organization    String?

  voiceprint      Json?

  firstSpoke      DateTime
  lastSpoke       DateTime
  totalDuration   Int
  segmentCount    Int
  wordCount       Int      @default(0)

  metadata        Json     @default("{}")
  createdAt       DateTime @default(now())

  session         Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  segments        TranscriptSegment[]

  @@map("speakers")
}

// ============================================================================
// REDACTION & PII
// ============================================================================

model Redaction {
  id                  String   @id @default(cuid())
  sessionId           String   @map("session_id")
  segmentId           String?  @map("segment_id")

  // Encrypted original text
  encryptedOriginal   String   @map("encrypted_original")
  encryptionNonce     String   @map("encryption_nonce")

  // Redacted representation
  redactedText        String   @map("redacted_text")
  piiType             String   @map("pii_type") // ssn, credit_card, etc.

  // Position in text
  startOffset         Int      @map("start_offset")
  endOffset           Int      @map("end_offset")

  // Metadata
  reason              String?
  legalBasis          String?  @map("legal_basis")

  // Access control
  createdBy           String   @map("created_by")
  accessControl       Json     @default("[]") @map("access_control") // Array of user IDs

  createdAt           DateTime @default(now()) @map("created_at")

  // Relations
  session             Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  segment             TranscriptSegment? @relation(fields: [segmentId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([segmentId])
  @@index([piiType])
  @@map("redactions")
}

// ============================================================================
// TRANSCRIPTION
// ============================================================================

model TranscriptSegment {
  id              String   @id @default(cuid())
  sessionId       String

  startMs         Int
  endMs           Int

  text            String   @db.Text

  speakerId       String?
  speakerName     String?

  confidence      Float?
  provider        String?

  isFinal         Boolean  @default(false)
  isEdited        Boolean  @default(false)
  editedBy        String?

  createdAt       DateTime @default(now())

  session         Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  speaker         Speaker? @relation(fields: [speakerId], references: [id], onDelete: SetNull)
  timestampProofs TimestampProof[]
  redactions      Redaction[]

  @@index([sessionId, startMs])
  @@index([speakerId])
  @@map("transcript_segments")
}

model TranscriptAccessLog {
  id              String   @id @default(cuid())
  sessionId       String
  userId          String?  @db.Uuid
  accessType      String
  accessMethod    String
  timestamp       DateTime @default(now())
  ipAddress       String?
  userAgent       String?

  session         Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, timestamp])
  @@index([userId, timestamp])
  @@map("transcript_access_logs")
}

// ============================================================================
// AI CHAT
// ============================================================================

model ChatMessage {
  id              String   @id @default(cuid())
  sessionId       String

  role            String
  content         String   @db.Text

  provider        String?
  model           String?
  tokens          Int?
  cost            Float?

  contextUsed     Json?

  createdAt       DateTime @default(now())

  session         Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  citations       Citation[]

  @@index([sessionId, createdAt])
  @@map("chat_messages")
}

// ============================================================================
// AI USAGE TRACKING
// ============================================================================

model ai_usage {
  id                  String   @id @db.Uuid @default(dbgenerated("gen_random_uuid()"))
  user_id             String   @db.Uuid
  provider            String
  model               String
  prompt_tokens       Int      @default(0)
  completion_tokens   Int      @default(0)
  total_tokens        Int      @default(0)
  cost                Decimal  @default(0) @db.Decimal(10, 6)
  purpose             String?
  metadata            Json?
  created_at          DateTime @default(now())

  user                User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, created_at])
  @@index([provider, model])
  @@index([purpose, created_at])
}

// ============================================================================
// CITATION CHECKING (AI-Powered)
// ============================================================================

model Citation {
  id              String   @id @default(cuid())
  chatMessageId   String?
  sessionId       String?
  documentId      String?

  citationType    String
  fullCitation    String   @db.Text
  shortCitation   String?

  jurisdiction    String?
  statuteCode     String?
  section         String?

  caseName        String?
  reporter        String?
  volume          Int?
  page            Int?
  year            Int?
  court           String?

  isVerified      Boolean  @default(false)
  verificationStatus String?
  verifiedAt      DateTime?
  verifiedBy      String?
  verificationNotes String? @db.Text

  treatmentStatus String?
  treatmentNotes  String?  @db.Text

  westlawUrl      String?
  lexisUrl        String?
  publicUrl       String?

  createdAt       DateTime @default(now())

  chatMessage     ChatMessage? @relation(fields: [chatMessageId], references: [id], onDelete: Cascade)

  @@index([sessionId, citationType])
  @@index([jurisdiction, statuteCode, section])
  @@index([isVerified, verificationStatus])
  @@map("citations")
}

// ============================================================================
// DOCUMENT GENERATION & EXPORT
// ============================================================================

model ExportJob {
  id                      String   @id @default(cuid())
  sessionId               String
  userId                  String   @db.Uuid

  format                  String
  template                String?

  includeLineNumbers      Boolean  @default(false)
  includeTimestamps       Boolean  @default(true)
  includePageNumbers      Boolean  @default(true)
  includeCertification    Boolean  @default(false)
  includeIndexPage        Boolean  @default(false)
  includeTableOfContents  Boolean  @default(false)

  certifiedBy             String?
  certificationDate       DateTime?
  certificationText       String?  @db.Text
  barNumber               String?

  status                  String   @default("pending")
  fileUrl                 String?
  fileSize                Int?

  error                   String?  @db.Text
  createdAt               DateTime @default(now())
  completedAt             DateTime?

  session                 Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user                    User     @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([sessionId])
  @@index([status])
  @@map("export_jobs")
}

model DocumentTemplate {
  id              String   @id @default(cuid())
  userId          String   @db.Uuid
  name            String
  description     String?  @db.Text

  fileUrl         String
  fields          Json

  courtType       String?
  documentType    String?
  jurisdiction    String?

  useCount        Int      @default(0)
  lastUsed        DateTime?

  isPublic        Boolean  @default(false)
  sharedWith      String[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  generatedDocs   GeneratedDocument[]

  @@index([userId, documentType])
  @@index([isPublic, jurisdiction])
  @@map("document_templates")
}

model GeneratedDocument {
  id              String   @id @default(cuid())
  templateId      String
  sessionId       String?
  matterId        String
  userId          String   @db.Uuid

  fileName        String
  fileUrl         String
  format          String

  fieldValues     Json

  version         Int      @default(1)
  parentId        String?

  status          String   @default("draft")

  createdAt       DateTime @default(now())

  template        DocumentTemplate @relation(fields: [templateId], references: [id])
  session         Session?  @relation(fields: [sessionId], references: [id], onDelete: SetNull)
  matter          Matter    @relation(fields: [matterId], references: [id], onDelete: Cascade)
  user            User      @relation(fields: [userId], references: [id])

  @@index([matterId, createdAt])
  @@index([templateId])
  @@index([userId, status])
  @@map("generated_documents")
}

// ============================================================================
// FEATURE 9: CONFLICT CHECKING
// ============================================================================

model ConflictCheck {
  id                  String    @id @default(cuid())
  userId              String    @db.Uuid

  // Check Parameters
  clientName          String?
  adverseParties      String[]
  companyNames        String[]
  matterDescription   String?   @db.Text
  excludeMatterId     String?

  // Results
  conflicts           Json      // Array of ConflictMatch objects
  riskLevel           String    // none, low, medium, high, critical
  totalMatches        Int       @default(0)
  highRiskCount       Int       @default(0)
  mediumRiskCount     Int       @default(0)
  lowRiskCount        Int       @default(0)
  recommendation      String    // proceed, review, decline
  summary             String    @db.Text

  // Resolution
  status              String    @default("pending") // pending, waived, declined, screened, cleared
  resolvedBy          String?
  resolvedAt          DateTime?
  resolutionNotes     String?   @db.Text

  // Audit
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relations
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("conflict_checks")
  @@index([userId, createdAt])
  @@index([status, riskLevel])
  @@index([clientName])
}

// ============================================================================
// FEATURE 10: BACKUP & DISASTER RECOVERY
// ============================================================================

model Backup {
  id              String   @id @default(cuid())
  userId          String?  @db.Uuid

  type            String
  scope           String
  scopeId         String?

  size            Int
  checksum        String

  encryptedWith   String?
  includesAudio   Boolean  @default(false)
  includesDocuments Boolean @default(true)

  metadata        Json     @default("{}")

  status          String   @default("pending")
  error           String?  @db.Text

  createdAt       DateTime @default(now())
  completedAt     DateTime?
  lastRestoredAt  DateTime?
  restoreCount    Int      @default(0)

  @@index([userId, createdAt])
  @@index([status, createdAt])
  @@map("backups")
}

// ============================================================================
// BILLING & TIME TRACKING
// ============================================================================

model BillableTime {
  id              String   @id @default(cuid())
  sessionId       String
  matterId        String
  userId          String   @db.Uuid

  startTime       DateTime
  endTime         DateTime
  durationSeconds Int
  billableSeconds Int

  hourlyRate      Float
  amount          Float

  activityType    String
  description     String?  @db.Text

  status          String   @default("draft")
  invoiceId       String?
  invoiceDate     DateTime?

  createdAt       DateTime @default(now())

  session         Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  matter          Matter   @relation(fields: [matterId], references: [id], onDelete: Cascade)
  user            User     @relation(fields: [userId], references: [id])

  @@index([matterId, createdAt])
  @@index([userId, status])
  @@index([invoiceId])
  @@map("billable_time")
}

// ============================================================================
// SYSTEM TABLES
// ============================================================================

model FeatureFlag {
  id              String   @id @default(cuid())
  name            String   @unique
  description     String?  @db.Text
  isEnabled       Boolean  @default(false)
  rolloutPercent  Int      @default(0)
  enabledForUsers String[]
  metadata        Json     @default("{}")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([isEnabled])
  @@map("feature_flags")
}

model SystemLog {
  id              String   @id @default(cuid())
  level           String
  service         String
  message         String   @db.Text
  error           String?  @db.Text
  stack           String?  @db.Text
  metadata        Json     @default("{}")
  timestamp       DateTime @default(now())

  @@index([level, timestamp])
  @@index([service, timestamp])
  @@map("system_logs")
}
